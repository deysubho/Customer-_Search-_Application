<<<<<<< HEAD
# Customer-_Search-_Application
This project is a configuration-driven Customer Search Application built with React, TypeScript, Tailwind CSS, and shadcn/ui, powered by a JSON Server mock API. The key idea is scalability and flexibility — adding or modifying customer fields should only require changes to configuration files, not component logic.
=======
# Customer Search Application

A configuration-driven React application for searching customers with TypeScript, Tailwind CSS, and shadcn/ui components.

## Features

- **Configuration-driven UI**: All form fields and display columns are defined through configuration objects
- **Responsive design**: Works on desktop and mobile devices
- **Real-time search**: Search customers by first name, last name, and date of birth
- **Clean UI**: Built with shadcn/ui components and Tailwind CSS
- **TypeScript**: Fully typed for better development experience

## Technology Stack

- React 18 with TypeScript
- Tailwind CSS for styling
- shadcn/ui components
- JSON Server for mock API
- Create React App for build tooling

## Setup Instructions

1. **Install dependencies**:
   ```bash
   npm install --legacy-peer-deps
   ```

2. **Start the JSON Server** (in one terminal):
   ```bash
   npm run server
   ```
   This starts the mock API server on http://localhost:3001

3. **Start the development server** (in another terminal):
   ```bash
   npm start
   ```
   This starts the React app on http://localhost:3000

4. **Open your browser** and navigate to http://localhost:3000

## Configuration Approach

The application uses a configuration-driven approach where UI components are rendered based on configuration objects rather than hardcoded components.

### Search Configuration

The search form is configured in `src/config/searchConfig.ts`:

```typescript
export const searchConfig: SearchConfig = {
  fields: {
    firstName: {
      uiType: 'input',
      label: 'First Name',
      renderOrder: 1,
      placeholder: 'Enter first name',
    },
    // ... more fields
  },
};
```

### Display Configuration

The results display is configured in the same file:

```typescript
export const displayConfig: DisplayConfig = {
  fields: {
    name: {
      label: 'Name',
      renderOrder: 1,
      getValue: (customer: Customer) => `${customer.firstName} ${customer.lastName}`,
    },
    // ... more fields
  },
};
```

## Adding a New Search Field

To add a new search field (e.g., "middleName"), you only need to update the configuration:

1. **Add the field to the Customer interface** in `src/types/index.ts`:
   ```typescript
   export interface Customer {
     // ... existing fields
     middleName?: string;
   }
   ```

2. **Add the field to SearchFilters interface**:
   ```typescript
   export interface SearchFilters {
     // ... existing fields
     middleName?: string;
   }
   ```

3. **Update the search configuration** in `src/config/searchConfig.ts`:
   ```typescript
   export const searchConfig: SearchConfig = {
     fields: {
       // ... existing fields
       middleName: {
         uiType: 'input',
         label: 'Middle Name',
         renderOrder: 2, // Insert between firstName and lastName
         placeholder: 'Enter middle name',
       },
     },
   };
   ```

4. **Update the display configuration** if you want to show the middle name:
   ```typescript
   name: {
     label: 'Name',
     renderOrder: 1,
     getValue: (customer: Customer) => 
       `${customer.firstName} ${customer.middleName || ''} ${customer.lastName}`.trim(),
   },
   ```

5. **Update the mock data** in `db.json` to include middle names for testing.

No changes to component code are required!

## Key Design Decisions

### 1. Configuration-First Approach
- All UI rendering is driven by configuration objects
- Components are generic and reusable
- Adding new fields requires only configuration changes

### 2. Type Safety
- Full TypeScript implementation with proper interfaces
- Configuration objects are strongly typed
- Runtime type safety through TypeScript compilation

### 3. Responsive Design
- Desktop: Table layout for better data scanning
- Mobile: Card layout for better touch interaction
- Automatic switching based on screen size

### 4. Error Handling
- Loading states during API calls
- Error messages for failed requests
- Empty state when no results found

### 5. API Integration
- Uses JSON Server for realistic API simulation
- Supports partial matching with `_like` queries
- Handles multiple search parameters

## Project Structure

```
src/
├── components/
│   ├── ui/                 # shadcn/ui components
│   ├── ConfigurableForm.tsx    # Generic form component
│   ├── CustomerResults.tsx     # Generic results component
│   └── CustomerSearch.tsx      # Main search orchestrator
├── config/
│   └── searchConfig.ts     # Configuration objects
├── types/
│   └── index.ts           # TypeScript interfaces
├── lib/
│   └── utils.ts           # Utility functions
└── globals.css            # Global styles
```

## Trade-offs and Considerations

### Pros
- **Highly maintainable**: Adding fields requires minimal code changes
- **Consistent UI**: All forms follow the same patterns
- **Type-safe**: Configuration is validated at compile time
- **Reusable**: Components can be used for different entity types

### Cons
- **Initial complexity**: More setup required than hardcoded forms
- **Learning curve**: Developers need to understand the configuration system
- **Over-engineering risk**: Simple forms might not need this level of abstraction

### Future Enhancements
- Field validation rules in configuration
- Conditional field rendering
- Custom field types (select dropdowns, multi-select, etc.)
- Field dependencies and dynamic behavior
- Export/import functionality for search results

## Time Spent

Approximately 4-5 hours total:
- Project setup and configuration: 1 hour
- Core components and types: 2 hours
- Configuration system implementation: 1.5 hours
- Testing and documentation: 0.5 hours
>>>>>>> 3aef5354 (Initial commit)

